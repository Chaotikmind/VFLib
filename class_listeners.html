<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VFLib: Listeners&lt; ListenerClass &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VFLib
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Listeners&lt; ListenerClass &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__vf__concurrent.html">vf_concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A group of concurrent <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a>.  
 <a href="class_listeners.html#details">More...</a></p>

<p><code>#include &quot;vf_Listeners.h&quot;</code></p>

<p>Inherits ListenersBase.</p>

<p><a href="class_listeners-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6addccea031c809ac4b3f4bb699f4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6">add</a> (ListenerClass *const listener, <a class="el" href="class_call_queue.html">CallQueue</a> &amp;callQueue)</td></tr>
<tr class="memdesc:aa6addccea031c809ac4b3f4bb699f4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a listener.  <a href="#aa6addccea031c809ac4b3f4bb699f4c6"></a><br/></td></tr>
<tr class="memitem:ab403aed0868a7919f0e8ce95296cdf46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46">remove</a> (ListenerClass *const listener)</td></tr>
<tr class="memdesc:ab403aed0868a7919f0e8ce95296cdf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a listener.  <a href="#ab403aed0868a7919f0e8ce95296cdf46"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a174db6d8ac775775578f860c6e97b600"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a174db6d8ac775775578f860c6e97b600"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600">call</a> (Mf mf)</td></tr>
<tr class="memdesc:a174db6d8ac775775578f860c6e97b600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on every added listener, on its associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.  <a href="#a174db6d8ac775775578f860c6e97b600"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a6ce1ff9fed14ef5bc35ef67c52379eaf">queue</a> (Mf mf)</td></tr>
<tr class="memdesc:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a member function on every added listener, without synchronizing.  <a href="#a6ce1ff9fed14ef5bc35ef67c52379eaf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a75f817c7795ad47168fdf3511a1edf30"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a75f817c7795ad47168fdf3511a1edf30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a75f817c7795ad47168fdf3511a1edf30">update</a> (Mf mf)</td></tr>
<tr class="memdesc:a75f817c7795ad47168fdf3511a1edf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on every added listener, replacing pending calls to the same member.  <a href="#a75f817c7795ad47168fdf3511a1edf30"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae6c2baac72cebcb4e01064b83727796c"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:ae6c2baac72cebcb4e01064b83727796c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#ae6c2baac72cebcb4e01064b83727796c">call1</a> (ListenerClass *const listener, Mf mf)</td></tr>
<tr class="memdesc:ae6c2baac72cebcb4e01064b83727796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on a specific listener.  <a href="#ae6c2baac72cebcb4e01064b83727796c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a5c0c14bbc7b07aadefc96b6ddfa1de0c">queue1</a> (ListenerClass *const listener, Mf mf)</td></tr>
<tr class="memdesc:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a member function on a specific listener.  <a href="#a5c0c14bbc7b07aadefc96b6ddfa1de0c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ListenerClass&gt;<br/>
class Listeners&lt; ListenerClass &gt;</h3>

<p>A group of concurrent <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a>. </p>
<p>A Listener is an object of class type which inherits from a defined interface, and registers on a provided instance of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> to receive asynchronous notifications of changes to concurrent states. Another way of defining <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a>, is that it is similar to a Juce <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classListenerList.html">ListenerList</a> but with the provision that the Listener registers with the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> upon which the notification should be made.</p>
<p><a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> makes extensive use of <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> for providing the notifications, and provides a higher level facility for implementing the concurrent synchronization strategy outlined in <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>. Therefore, the same notes which apply to functors in <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> also apply to Listener member invocations. Their execution time should be brief, limited in scope to updating the recipient's view of a shared state, and use reference counting for parameters of class type.</p>
<p>To use this system, first declare your Listener interface:</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>Listener</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Sent on every output block</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keyword">const</span> <span class="keywordtype">float</span> outputLevel) { }</div>
<div class="line">  };</div>
</div><!-- fragment --><p>Now set up the place where you want to send the notifications. In this example, we will set up the <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a> to notify anyone who is interested about changes in the current audio output level. We will use this to implement a VU meter:</p>
<div class="fragment"><div class="line">  <a class="code" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners &lt;Listener&gt;</a> listeners;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// (Process audio data)</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Calculate output level</span></div>
<div class="line">  <span class="keywordtype">float</span> outputLevel = calcOutputLevel ();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Notify listeners</span></div>
<div class="line">  listeners.<a class="code" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call</a> (&amp;Listener::onOutputLevelChanged, outputLevel);</div>
</div><!-- fragment --><p>To receive notifications, derive from Listener and then add yourself to the <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> object using the desired <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.</p>
<div class="fragment"><div class="line">  <span class="comment">// We want notifications on the message thread</span></div>
<div class="line">  <a class="code" href="class_gui_call_queue.html" title="A CallQueue handled by the JUCE message thread (gui).">GuiCallQueue</a> fifo;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">struct </span>VUMeter : <span class="keyword">public</span> Listener, <span class="keyword">public</span> <a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classComponent.html">Component</a></div>
<div class="line">  {</div>
<div class="line">    VUMeter () : m_outputLevel (0)</div>
<div class="line">    {</div>
<div class="line">      listeners.<a class="code" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6" title="Add a listener.">add</a> (<span class="keyword">this</span>, fifo);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~VUMeter ()</div>
<div class="line">    {</div>
<div class="line">      listeners.<a class="code" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove</a> (<span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keywordtype">float</span> outputLevel)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Update our copy of the output level shared state.</span></div>
<div class="line">      m_outputLevel = outputLevel;</div>
<div class="line">        </div>
<div class="line">      <span class="comment">// Now trigger a redraw of the control.</span></div>
<div class="line">      repaint ();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> m_outputLevel;</div>
<div class="line">  };</div>
</div><!-- fragment --><p>In this example, the VUMeter constructs with the output level set to zero, and must wait for a notification before it shows up to date data. For a simple VU meter, this is likely not a problem. But if the shared state contains complex information, such as dynamically allocated objects with rich data, then we need a more solid system.</p>
<p>We will add some classes to create a complete robust example of the use of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> to synchronize shared state:</p>
<div class="fragment"><div class="line">  <span class="comment">// Handles audio device output.</span></div>
<div class="line">  <span class="keyword">class </span>AudioDeviceOutput : <span class="keyword">public</span> <a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">struct </span>Listener</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Sent on every output block.</span></div>
<div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keywordtype">float</span> outputLevel) { }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    AudioDeviceOutput () : AudioDeviceOutput (<span class="stringliteral">&quot;Audio CallQueue&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~AudioDeviceOutput ()</div>
<div class="line">    {</div>
<div class="line">      m_fifo.close ();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> addListener (Listener* listener, <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>&amp; callQueue)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Acquire read access to the shared state.</span></div>
<div class="line">      <a class="code" href="class_concurrent_state_1_1_read_access.html" title="Read only access to a ConcurrentState.">ConcurrentState &lt;State&gt;::ReadAccess</a> state (m_state);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Add the listener.</span></div>
<div class="line">      m_listeners.add (listener, callQueue);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Queue an update for the listener to receive the initial state.</span></div>
<div class="line">      m_listeners.queue1 (listener,</div>
<div class="line">                          &amp;Listener::onOutputLevelChanged,</div>
<div class="line">                          state-&gt;outputLevel);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> removeListener (Listener* listener)</div>
<div class="line">    {</div>
<div class="line">      m_listeners.remove (listener);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> audioDeviceIOCallback (<span class="keyword">const</span> <span class="keywordtype">float</span>** inputChannelData,</div>
<div class="line">                          <span class="keywordtype">int</span> numInputChannels,</div>
<div class="line">                          <span class="keywordtype">float</span>** outputChannelData,</div>
<div class="line">                          <span class="keywordtype">int</span> numOutputChannels,</div>
<div class="line">                          <span class="keywordtype">int</span> numSamples)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Synchronize our call queue. Not needed for this example but</span></div>
<div class="line">      <span class="comment">// included here as a best-practice for audio device I/O callbacks.</span></div>
<div class="line">      m_fifo.synchronize ();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// (Process audio data)</span></div>
<div class="line"></div>
<div class="line">      <span class="comment">// Calculate output level.</span></div>
<div class="line">      <span class="keywordtype">float</span> newOutputLevel = calcOutputLevel ();</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Update shared state.</span></div>
<div class="line">      {</div>
<div class="line">        <a class="code" href="class_concurrent_state_1_1_write_access.html" title="Read/write access to a ConcurrentState.">ConcurrentState &lt;State&gt;::WriteAccess</a> state (m_state);</div>
<div class="line">          </div>
<div class="line">        m_state-&gt;outputLevel = newOutputLevel;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// Notify listeners.</span></div>
<div class="line">      listeners.<a class="code" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call</a> (&amp;Listener::onOutputLevelChanged, newOutputLevel);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>State</div>
<div class="line">    {</div>
<div class="line">      State () : outputLevel (0) { }</div>
<div class="line"></div>
<div class="line">      <span class="keywordtype">float</span> outputLevel;</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_concurrent_state.html" title="Structured access to a shared state.">ConcurrentState &lt;State&gt;</a> m_state;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_manual_call_queue.html" title="A CallQueue that requires periodic manual synchronization.">ManualCallQueue</a> m_fifo;</div>
<div class="line">  };</div>
</div><!-- fragment --><p>Although the rigor demonstrated in the example above is not strictly required when the shared state consists only of a single float, it becomes necessary when there are dynamically allocated objects with complex interactions in the shared state.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa6addccea031c809ac4b3f4bb699f4c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::add </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_call_queue.html">CallQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>callQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a listener. </p>
<p>The specified listener is associated with the specified <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> and added to the list.</p>
<p>Invariants:</p>
<ul>
<li>All other members of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> are blocked during <a class="el" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6" title="Add a listener.">add()</a>.</li>
</ul>
<ul>
<li>The listener is guaranteed to receive every subsequent call.</li>
</ul>
<ul>
<li>The listener must not already exist in the list.</li>
</ul>
<ul>
<li>Safe to call from any thread.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to add.</td></tr>
    <tr><td class="paramname">callQueue</td><td>The <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> to associate with the listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab403aed0868a7919f0e8ce95296cdf46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a listener. </p>
<p>The specified listener, which must have been previously added, is removed from the list. A listener always needs to remove itself before the associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is closed.</p>
<p>Invariants:</p>
<ul>
<li>All other members of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> are blocked during <a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove()</a>.</li>
</ul>
<ul>
<li>The listener is guaranteed not to receive calls after <a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove()</a> returns.</li>
</ul>
<ul>
<li>Safe to call from any thread.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a174db6d8ac775775578f860c6e97b600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::call </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a member function on every added listener, on its associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>. </p>
<p>A listener's <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> will be synchronized if this function is called from it's associated thread.</p>
<p>Invariants:</p>
<ul>
<li>A listener that later removes itself afterwards may not get called.</li>
</ul>
<ul>
<li>Calls from the same thread always execute in order.</li>
</ul>
<ul>
<li>A listener can remove itself even if it has a pending call.</li>
</ul>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ce1ff9fed14ef5bc35ef67c52379eaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::queue </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue a member function on every added listener, without synchronizing. </p>
<p>Operates like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, but no <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> synchronization takes place. This can be necessary when the call to <a class="el" href="class_listeners.html#a6ce1ff9fed14ef5bc35ef67c52379eaf" title="Queue a member function on every added listener, without synchronizing.">queue()</a> is made inside a held lock.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75f817c7795ad47168fdf3511a1edf30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::update </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a member function on every added listener, replacing pending calls to the same member. </p>
<p>This operates like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, except that if there are pending unprocessed calls to the same member function,they will be replaced, with the previous parameters destroyed normally. This functionality is useful for high frequency notifications of non critical data, where the recipient may not catch up often enough. For example, the output level of the <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a> in the example is a candidate for the use of <a class="el" href="class_listeners.html#a75f817c7795ad47168fdf3511a1edf30" title="Call a member function on every added listener, replacing pending calls to the same member...">update()</a>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6c2baac72cebcb4e01064b83727796c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::call1 </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a member function on a specific listener. </p>
<p>Like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, except that one listener is targeted only. This is useful when builing complex behaviors during the addition of a listener, such as providing an initial state.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to call.</td></tr>
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c0c14bbc7b07aadefc96b6ddfa1de0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::queue1 </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue a member function on a specific listener. </p>
<p>Like <a class="el" href="class_listeners.html#ae6c2baac72cebcb4e01064b83727796c" title="Call a member function on a specific listener.">call1()</a>, except that no <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> synchronization takes place.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to call.</td></tr>
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vf_Listeners.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
