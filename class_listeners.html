<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VFLib: Listeners&lt; ListenerClass &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">VFLib
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Listeners&lt; ListenerClass &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__vf__concurrent.html">vf_concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A group of concurrent <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a>.  
 <a href="class_listeners.html#details">More...</a></p>

<p><code>#include &quot;vf_Listeners.h&quot;</code></p>

<p>Inherits ListenersBase.</p>

<p><a href="class_listeners-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa6addccea031c809ac4b3f4bb699f4c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6">add</a> (ListenerClass *const listener, <a class="el" href="class_call_queue.html">CallQueue</a> &amp;callQueue)</td></tr>
<tr class="memdesc:aa6addccea031c809ac4b3f4bb699f4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a listener.  <a href="#aa6addccea031c809ac4b3f4bb699f4c6"></a><br/></td></tr>
<tr class="memitem:ab403aed0868a7919f0e8ce95296cdf46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46">remove</a> (ListenerClass *const listener)</td></tr>
<tr class="memdesc:ab403aed0868a7919f0e8ce95296cdf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a listener.  <a href="#ab403aed0868a7919f0e8ce95296cdf46"></a><br/></td></tr>
<tr class="memitem:a174db6d8ac775775578f860c6e97b600"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a174db6d8ac775775578f860c6e97b600"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600">call</a> (Mf mf)</td></tr>
<tr class="memdesc:a174db6d8ac775775578f860c6e97b600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on every added listener, on its associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.  <a href="#a174db6d8ac775775578f860c6e97b600"></a><br/></td></tr>
<tr class="memitem:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a6ce1ff9fed14ef5bc35ef67c52379eaf">queue</a> (Mf mf)</td></tr>
<tr class="memdesc:a6ce1ff9fed14ef5bc35ef67c52379eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a member function on every added listener, without synchronizing.  <a href="#a6ce1ff9fed14ef5bc35ef67c52379eaf"></a><br/></td></tr>
<tr class="memitem:a75f817c7795ad47168fdf3511a1edf30"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a75f817c7795ad47168fdf3511a1edf30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a75f817c7795ad47168fdf3511a1edf30">update</a> (Mf mf)</td></tr>
<tr class="memdesc:a75f817c7795ad47168fdf3511a1edf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on every added listener, replacing pending calls to the same member.  <a href="#a75f817c7795ad47168fdf3511a1edf30"></a><br/></td></tr>
<tr class="memitem:ae6c2baac72cebcb4e01064b83727796c"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:ae6c2baac72cebcb4e01064b83727796c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#ae6c2baac72cebcb4e01064b83727796c">call1</a> (ListenerClass *const listener, Mf mf)</td></tr>
<tr class="memdesc:ae6c2baac72cebcb4e01064b83727796c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a member function on a specific listener.  <a href="#ae6c2baac72cebcb4e01064b83727796c"></a><br/></td></tr>
<tr class="memitem:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="memTemplParams" colspan="2">template&lt;class Mf &gt; </td></tr>
<tr class="memitem:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_listeners.html#a5c0c14bbc7b07aadefc96b6ddfa1de0c">queue1</a> (ListenerClass *const listener, Mf mf)</td></tr>
<tr class="memdesc:a5c0c14bbc7b07aadefc96b6ddfa1de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a member function on a specific listener.  <a href="#a5c0c14bbc7b07aadefc96b6ddfa1de0c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class ListenerClass&gt;<br/>
class Listeners&lt; ListenerClass &gt;</h3>

<p>A Listener is an object of class type which inherits from a defined interface, and registers on a provided instance of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> to receive asynchronous notifications of changes to concurrent states. Another way of defining <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a>, is that it is similar to a Juce <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classListenerList.html">ListenerList</a> but with the provision that the Listener registers with the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> upon which the notification should be made.</p>
<p><a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> makes extensive use of <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> for providing the notifications, and provides a higher level facility for implementing the concurrent synchronization strategy outlined in <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>. Therefore, the same notes which apply to functors in <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> also apply to Listener member invocations. Their execution time should be brief, limited in scope to updating the recipient's view of a shared state, and use reference counting for parameters of class type.</p>
<p>To use this system, first declare your Listener interface:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">struct </span>Listener
    {
      <span class="comment">// Sent on every output block</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keyword">const</span> <span class="keywordtype">float</span> outputLevel) { }
    };
</pre></div><p>Now set up the place where you want to send the notifications. In this example, we will set up the <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a> to notify anyone who is interested about changes in the current audio output level. We will use this to implement a VU meter:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners &lt;Listener&gt;</a> listeners;

    <span class="comment">// (Process audio data)</span>

    <span class="comment">// Calculate output level</span>
    <span class="keywordtype">float</span> outputLevel = calcOutputLevel ();

    <span class="comment">// Notify listeners</span>
    listeners.<a class="code" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call</a> (&amp;Listener::onOutputLevelChanged, outputLevel);
</pre></div><p>To receive notifications, derive from Listener and then add yourself to the <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> object using the desired <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// We want notifications on the message thread</span>
    <a class="code" href="class_gui_call_queue.html" title="A CallQueue handled by the Juce message thread (gui).">GuiCallQueue</a> fifo;

    <span class="keyword">struct </span>VUMeter : <span class="keyword">public</span> Listener, <span class="keyword">public</span> <a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classComponent.html">Component</a>
    {
      VUMeter () : m_outputLevel (0)
      {
        listeners.<a class="code" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6" title="Add a listener.">add</a> (<span class="keyword">this</span>, fifo);
      }

      ~VUMeter ()
      {
        listeners.<a class="code" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove</a> (<span class="keyword">this</span>);
      }

      <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keywordtype">float</span> outputLevel)
      {
        <span class="comment">// Update our copy of the output level shared state.</span>
        m_outputLevel = outputLevel;
        
        <span class="comment">// Now trigger a redraw of the control.</span>
        repaint ();
      }

      <span class="keywordtype">float</span> m_outputLevel;
    };
</pre></div><p>In this example, the VUMeter constructs with the output level set to zero, and must wait for a notification before it shows up to date data. For a simple VU meter, this is likely not a problem. But if the shared state contains complex information, such as dynamically allocated objects with rich data, then we need a more solid system.</p>
<p>We will add some classes to create a complete robust example of the use of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> to synchronize shared state:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// Handles audio device output.</span>
    <span class="keyword">class </span>AudioDeviceOutput : <span class="keyword">public</span> <a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a>
    {
    <span class="keyword">public</span>:
      <span class="keyword">struct </span>Listener
      {
        <span class="comment">// Sent on every output block.</span>
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> onOutputLevelChanged (<span class="keywordtype">float</span> outputLevel) { }
      };

      AudioDeviceOutput () : AudioDeviceOutput (<span class="stringliteral">&quot;Audio CallQueue&quot;</span>)
      {
      }

      ~AudioDeviceOutput ()
      {
        <span class="comment">// Synchronize required since we&#39;re using a ManualCallQueue.</span>
        m_fifo.synchronize ();

        m_fifo.close ();
      }

      <span class="keywordtype">void</span> addListener (Listener* listener, <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>&amp; callQueue)
      {
        <span class="comment">// Acquire read access to the shared state.</span>
        <a class="code" href="class_concurrent_state_1_1_read_access.html" title="Read only access to a ConcurrentState.">ConcurrentState &lt;State&gt;::ReadAccess</a> state (m_state);

        <span class="comment">// Add the listener.</span>
        m_listeners.add (listener, callQueue);

        <span class="comment">// Queue an update for the listener to receive the initial state.</span>
        m_listeners.queue1 (listener,
                            &amp;Listener::onOutputLevelChanged,
                            state-&gt;outputLevel);
      }

      <span class="keywordtype">void</span> removeListener (Listener* listener)
      {
        m_listeners.remove (listener);
      }

    <span class="keyword">protected</span>:
      <span class="keywordtype">void</span> audioDeviceIOCallback (<span class="keyword">const</span> <span class="keywordtype">float</span>** inputChannelData,
                                  <span class="keywordtype">int</span> numInputChannels,
                                  <span class="keywordtype">float</span>** outputChannelData,
                                  <span class="keywordtype">int</span> numOutputChannels,
                                  <span class="keywordtype">int</span> numSamples)
      {
        <span class="comment">// Synchronize our call queue. Not needed for this example but</span>
        <span class="comment">// included here as a best-practice for audio device I/O callbacks.</span>
        m_fifo.synchronize ();

        <span class="comment">// (Process audio data)</span>

        <span class="comment">// Calculate output level.</span>
        <span class="keywordtype">float</span> newOutputLevel = calcOutputLevel ();

        <span class="comment">// Update shared state.</span>
        {
          <a class="code" href="class_concurrent_state_1_1_write_access.html" title="Read/write access to a ConcurrentState.">ConcurrentState &lt;State&gt;::WriteAccess</a> state (m_state);
          
          m_state-&gt;outputLevel = newOutputLevel;
        }

        <span class="comment">// Notify listeners.</span>
        listeners.<a class="code" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call</a> (&amp;Listener::onOutputLevelChanged, newOutputLevel);
      }

    <span class="keyword">private</span>:
      <span class="keyword">struct </span>State
      {
        State () : outputLevel (0) { }

        <span class="keywordtype">float</span> outputLevel;
      };

      <a class="code" href="class_concurrent_state.html" title="Structured access to a shared state.">ConcurrentState &lt;State&gt;</a> m_state;

      <a class="code" href="class_manual_call_queue.html" title="A CallQueue that requires periodic manual synchronization.">ManualCallQueue</a> m_fifo;
    };
</pre></div><p>Although the rigor demonstrated in the example above is not strictly required when the shared state consists only of a single float, it becomes necessary when there are dynamically allocated objects with complex interactions in the shared state.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> </dd></dl>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa6addccea031c809ac4b3f4bb699f4c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6">add</a> </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_call_queue.html">CallQueue</a> &amp;&#160;</td>
          <td class="paramname"><em>callQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The specified listener is associated with the specified <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> and added to the list.</p>
<p>Invariants:</p>
<ul>
<li>All other members of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> are blocked during <a class="el" href="class_listeners.html#aa6addccea031c809ac4b3f4bb699f4c6" title="Add a listener.">add()</a>.</li>
</ul>
<ul>
<li>The listener is guaranteed to receive every subsequent call.</li>
</ul>
<ul>
<li>The listener must not already exist in the list.</li>
</ul>
<ul>
<li>Safe to call from any thread.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to add.</td></tr>
    <tr><td class="paramname">callQueue</td><td>The <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> to associate with the listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab403aed0868a7919f0e8ce95296cdf46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46">remove</a> </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The specified listener, which must have been previously added, is removed from the list. A listener always needs to remove itself before the associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is closed.</p>
<p>Invariants:</p>
<ul>
<li>All other members of <a class="el" href="class_listeners.html" title="A group of concurrent Listeners.">Listeners</a> are blocked during <a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove()</a>.</li>
</ul>
<ul>
<li>The listener is guaranteed not to receive calls after <a class="el" href="class_listeners.html#ab403aed0868a7919f0e8ce95296cdf46" title="Remove a listener.">remove()</a> returns.</li>
</ul>
<ul>
<li>Safe to call from any thread.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a174db6d8ac775775578f860c6e97b600"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600">call</a> </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A listener's <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> will be synchronized if this function is called from it's associated thread.</p>
<p>Invariants:</p>
<ul>
<li>A listener that later removes itself afterwards may not get called.</li>
</ul>
<ul>
<li>Calls from the same thread always execute in order.</li>
</ul>
<ul>
<li>A listener can remove itself even if it has a pending call.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ce1ff9fed14ef5bc35ef67c52379eaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#a6ce1ff9fed14ef5bc35ef67c52379eaf">queue</a> </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operates like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, but no <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> synchronization takes place. This can be necessary when the call to <a class="el" href="class_listeners.html#a6ce1ff9fed14ef5bc35ef67c52379eaf" title="Queue a member function on every added listener, without synchronizing.">queue()</a> is made inside a held lock.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75f817c7795ad47168fdf3511a1edf30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#a75f817c7795ad47168fdf3511a1edf30">update</a> </td>
          <td>(</td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This operates like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, except that if there are pending unprocessed calls to the same member function,they will be replaced, with the previous parameters destroyed normally. This functionality is useful for high frequency notifications of non critical data, where the recipient may not catch up often enough. For example, the output level of the <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a> in the example is a candidate for the use of <a class="el" href="class_listeners.html#a75f817c7795ad47168fdf3511a1edf30" title="Call a member function on every added listener, replacing pending calls to the same member...">update()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6c2baac72cebcb4e01064b83727796c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#ae6c2baac72cebcb4e01064b83727796c">call1</a> </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <a class="el" href="class_listeners.html#a174db6d8ac775775578f860c6e97b600" title="Call a member function on every added listener, on its associated CallQueue.">call()</a>, except that one listener is targeted only. This is useful when builing complex behaviors during the addition of a listener, such as providing an initial state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to call.</td></tr>
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c0c14bbc7b07aadefc96b6ddfa1de0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ListenerClass&gt; </div>
<div class="memtemplate">
template&lt;class Mf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_listeners.html">Listeners</a>&lt; ListenerClass &gt;::<a class="el" href="class_listeners.html#a5c0c14bbc7b07aadefc96b6ddfa1de0c">queue1</a> </td>
          <td>(</td>
          <td class="paramtype">ListenerClass *const&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mf&#160;</td>
          <td class="paramname"><em>mf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like <a class="el" href="class_listeners.html#ae6c2baac72cebcb4e01064b83727796c" title="Call a member function on a specific listener.">call1()</a>, except that no <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> synchronization takes place.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The listener to call.</td></tr>
    <tr><td class="paramname">mf</td><td>The member function to call. This may be followed by up to 8 arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vf_Listeners.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 25 2012 21:48:56 for VFLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
