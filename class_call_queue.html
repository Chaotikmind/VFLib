<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VFLib: CallQueue Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">VFLib
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CallQueue Class Reference<div class="ingroups"><a class="el" href="group__vf__concurrent.html">vf_concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A FIFO for calling functors asynchronously.  
 <a href="class_call_queue.html#details">More...</a></p>

<p><code>#include &quot;vf_CallQueue.h&quot;</code></p>

<p>Inherited by <a class="el" href="class_gui_call_queue.html">GuiCallQueue</a>, <a class="el" href="class_manual_call_queue.html">ManualCallQueue</a>, and <a class="el" href="class_thread_with_call_queue.html">ThreadWithCallQueue</a>.</p>

<p><a href="class_call_queue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89de47524d62877f2198a58d78d1b0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a89de47524d62877f2198a58d78d1b0ed">CallQueue</a> (<a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a> name)</td></tr>
<tr class="memitem:a243ab6a2217eb227bf4b6050447ead01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a243ab6a2217eb227bf4b6050447ead01">~CallQueue</a> ()</td></tr>
<tr class="memitem:aeb35530fa2af19554d407028bdb18621"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:aeb35530fa2af19554d407028bdb18621"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aeb35530fa2af19554d407028bdb18621">callf</a> (Functor const &amp;f)</td></tr>
<tr class="memdesc:aeb35530fa2af19554d407028bdb18621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a functor and possibly synchronize.  <a href="#aeb35530fa2af19554d407028bdb18621"></a><br/></td></tr>
<tr class="memitem:a7cbce7a131504706ba6c36bcab846f87"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a7cbce7a131504706ba6c36bcab846f87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">call</a> (Fn f)</td></tr>
<tr class="memdesc:a7cbce7a131504706ba6c36bcab846f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call and possibly synchronize.  <a href="#a7cbce7a131504706ba6c36bcab846f87"></a><br/></td></tr>
<tr class="memitem:aa5b9237e85067d7199fab8b1bd20bb90"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:aa5b9237e85067d7199fab8b1bd20bb90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aa5b9237e85067d7199fab8b1bd20bb90">queuef</a> (Functor const &amp;f)</td></tr>
<tr class="memdesc:aa5b9237e85067d7199fab8b1bd20bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a functor without synchronizing.  <a href="#aa5b9237e85067d7199fab8b1bd20bb90"></a><br/></td></tr>
<tr class="memitem:a7b7121a53b44c35b82358544a6a7cea0"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a7b7121a53b44c35b82358544a6a7cea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">queue</a> (Fn f)</td></tr>
<tr class="memdesc:a7b7121a53b44c35b82358544a6a7cea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call without synchronizing.  <a href="#a7b7121a53b44c35b82358544a6a7cea0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7b4ecb95445c00c815bc2407c9e008b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7">synchronize</a> ()</td></tr>
<tr class="memdesc:a7b4ecb95445c00c815bc2407c9e008b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the queue.  <a href="#a7b4ecb95445c00c815bc2407c9e008b7"></a><br/></td></tr>
<tr class="memitem:ace99f6efb1cd9e6b3e0dac80fbb15690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#ace99f6efb1cd9e6b3e0dac80fbb15690">close</a> ()</td></tr>
<tr class="memdesc:ace99f6efb1cd9e6b3e0dac80fbb15690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the queue.  <a href="#ace99f6efb1cd9e6b3e0dac80fbb15690"></a><br/></td></tr>
<tr class="memitem:a0b243598ec53b127ac0557a1be058a4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a0b243598ec53b127ac0557a1be058a4c">signal</a> ()=0</td></tr>
<tr class="memdesc:a0b243598ec53b127ac0557a1be058a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the queue becomes signaled.  <a href="#a0b243598ec53b127ac0557a1be058a4c"></a><br/></td></tr>
<tr class="memitem:a171530cbaa7b1b4f4712aa940e7cd64c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a171530cbaa7b1b4f4712aa940e7cd64c">reset</a> ()=0</td></tr>
<tr class="memdesc:a171530cbaa7b1b4f4712aa940e7cd64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the queue becomes non-signaled.  <a href="#a171530cbaa7b1b4f4712aa940e7cd64c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><div class="fragment"><pre class="fragment">This object is an alternative to traditional locking techniques used to
implement concurrent systems. Instead of acquiring a mutex to change shared
data, a functor is queued for later execution (usually on another thread). The
execution of the functor applies the transformation to the shared state that
was formerly performed within a lock (i.e. CriticalSection).

For read operations on shared data, instead of acquiring a mutex and
accessing the data directly, copies are made (one for each thread), and the
thread accesses its copy without acquiring a lock. One thread owns the master
copy of the shared state. Requests for changing shared state are made by other
threads by posting functors to the master thread's CallQueue. The master
thread notifies other threads of changes by posting functors to their
respective associated CallQueue, using the Listeners interface.

The purpose of the functor is to encapsulate one mutation of shared state to
guarantee progress towards a consensus of the concurrent data among
participating threads. Functors should execute quickly, ideally in constant
time. Dynamically allocated objects of class type passed as functor parameters
should, in general, be reference counted. The ConcurrentObject class is ideal
for meeting this requirement, and has the additional benefit that the workload
of deletion is performed on a separate, provided thread. This queue is not a
replacement for a thread pool or job queue type system.

A CallQueue is considered signaled when one or more functors are present.
Functors are executed during a call to synchronize(). The operation of
executing functors via the call to synchronize() is called synchronizing
the queue. It can more generally be thought of as synchronizing multiple
copies of shared data between threads.

Although there is some extra work required to set up and maintain this
system, the benefits are significant. Since shared data is only synchronized
at well defined times, the programmer can reason and make strong statements
about the correctness of the concurrent system. For example, if an
AudioIODeviceCallback synchronizes the CallQueue only at the beginning of its
execution, it is guaranteed that shared data will remain the same throughout
the remainder of the function.

Because shared data is accessed for reading without a lock, upper bounds
on the run time performance can easily be calculated and assured. Compare
this with the use of a mutex - the run time performance experiences a
combinatorial explosion of possibilities depending on the complex interaction
of multiple threads.

Since a CallQueue is almost always used to invoke parameterized member
functions of objects, the call() function comes in a variety of convenient
forms to make usage easy:</pre></div> <div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> func1 (<span class="keywordtype">int</span>);

    <span class="keyword">struct </span>Object
    {
      <span class="keywordtype">void</span> func2 (<span class="keywordtype">void</span>);
      <span class="keywordtype">void</span> func3 (<a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a> name);

      <span class="keyword">static</span> <span class="keywordtype">void</span> func4 ();
    };

    <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> fifo (<span class="stringliteral">&quot;Example&quot;</span>);

    <span class="keywordtype">void</span> example ()
    {
      fifo.call (func1, 42);               <span class="comment">// same as: func1 (42)</span>

      Object* <span class="keywordtype">object</span> = <span class="keyword">new</span> Object;

      fifo.call (&amp;Object::func2, <span class="keywordtype">object</span>);  <span class="comment">// same as: object-&gt;func2 ()</span>

      fifo.call (&amp;Object::func3,           <span class="comment">// same as: object-&gt;funcf (&quot;Label&quot;)</span>
                 <span class="keywordtype">object</span>,
                 <span class="stringliteral">&quot;Label&quot;</span>);

      fifo.call (&amp;Object::func4);          <span class="comment">// even static members can be called.</span>

      fifo.callf (bind (&amp;Object::func2,    <span class="comment">// same as: object-&gt;func2 ()</span>
                        <span class="keywordtype">object</span>));
    }
</pre></div><dl class="section invariant"><dt>Invariant:</dt><dd>Functors can be added from any thread at any time, to any queue which is not closed.</dd>
<dd>
When <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called, functors are called and deleted.</dd>
<dd>
The thread from which <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called is considered the thread associated with the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.</dd>
<dd>
Functors queued by the same thread always execute in the same order they were queued.</dd>
<dd>
Functors are guaranteed to execute. It is an error if the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is deleted while there are functors in it.</dd></dl>
<p>Normally, you will not use <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> directly, but one of its subclasses instead. The <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is one of a handful of objects that work together to implement this system of concurrent data access.</p>
<p>For performance considerations, this implementation is wait-free for producers and mostly wait-free for consumers. It also uses a lock-free and wait-free (in the fast path) custom memory allocator.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_gui_call_queue.html" title="A CallQueue handled by the Juce message thread (gui).">GuiCallQueue</a>, <a class="el" href="class_manual_call_queue.html" title="A CallQueue that requires periodic manual synchronization.">ManualCallQueue</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Standardize terminology: "functor" to represent the stored item. </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89de47524d62877f2198a58d78d1b0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_call_queue.html#a89de47524d62877f2198a58d78d1b0ed">CallQueue::CallQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string to identify the queue during debugging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a243ab6a2217eb227bf4b6050447ead01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_call_queue.html#a243ab6a2217eb227bf4b6050447ead01">CallQueue::~CallQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section invariant"><dt>Invariant:</dt><dd>Destroying a queue that contains functors is undefined. </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aeb35530fa2af19554d407028bdb18621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#aeb35530fa2af19554d407028bdb18621">CallQueue::callf</a> </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use this when you want to perform the bind yourself.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to add, typically the return value of a call to bind().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7cbce7a131504706ba6c36bcab846f87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">  Parameters are evaluated immediately and added to the queue as a packaged
  functor. If the current thread of execution is the same as the thread
  associated with the CallQueue, synchronize() is called automatically. This
  behavior can be avoided by using queue() instead.

  @param f The function to call followed by up to eight parameters, evaluated
           immediately. The parameter list must match the function signature.
           For class member functions, the first argument must be a pointer
           to the class object.

  @see queue</pre></div> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Provide an example of when <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is needed in <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b9237e85067d7199fab8b1bd20bb90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#aa5b9237e85067d7199fab8b1bd20bb90">CallQueue::queuef</a> </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use this when you want to perform the bind yourself.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to add, typically the return value of a call to bind().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b7121a53b44c35b82358544a6a7cea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment"> Parameters are evaluated immediately, then the resulting functor is added
 to the queue. This is used to postpone the call to synchronize() when
 there would be adverse side effects to executing the function immediately.
 In this example, we use queue() instead of call() to avoid a deadlock:</pre></div> <div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>SharedState;           <span class="comment">// contains data shared between threads</span>

      <a class="code" href="class_concurrent_state.html" title="Structured access to a shared state.">ConcurrentState &lt;SharedState&gt;</a> sharedState;

      <span class="keywordtype">void</span> stateChanged ()
      {
        <a class="code" href="class_concurrent_state_1_1_read_access.html" title="Read only access to a ConcurrentState.">ConcurrentState &lt;SharedState&gt;::ReadAccess</a> state (sharedState);

        <span class="comment">// (access state)</span>
      }

      <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> fifo;

      <span class="keywordtype">void</span> changeState ()
      {
        <a class="code" href="class_concurrent_state_1_1_write_access.html" title="Read/write access to a ConcurrentState.">ConcurrentState &lt;State&gt;::WriteAccess</a> state (sharedState);

        <span class="comment">// (modify state)</span>

        fifo.<a class="code" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call</a> (&amp;stateChanged);  <span class="comment">// BUG: DEADLOCK because of the implicit synchronize().</span>

        fifo.<a class="code" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue</a> (&amp;stateChanged); <span class="comment">// Okay, synchronize() will be called later,</span>
                                    <span class="comment">// after the write lock is released.</span>
      }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to call followed by up to eight parameters, evaluated immediately. The parameter list must match the function signature. For non-static class member functions, the first argument must be a pointer an instance of the class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b4ecb95445c00c815bc2407c9e008b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7">CallQueue::synchronize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A synchronize operation calls all functors in the queue. If a functor causes additional functors to be added, they are eventually executed before <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> returns. Derived class call this when the queue is signaled, and optionally at any other time. Calling this function from more than one thread simultaneously is undefined.</p>
<dl class="section return"><dt>Returns:</dt><dd>true if any functors were executed. </dd></dl>

<p>Reimplemented in <a class="el" href="class_manual_call_queue.html#a8934bcdca202c9f5d190565f68583687">ManualCallQueue</a>, and <a class="el" href="class_gui_call_queue.html#a63f2c96d55cc954cf373d85f509f6dd3">GuiCallQueue</a>.</p>

</div>
</div>
<a class="anchor" id="ace99f6efb1cd9e6b3e0dac80fbb15690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#ace99f6efb1cd9e6b3e0dac80fbb15690">CallQueue::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functors may not be added after this routine is called. This is used for diagnostics, to track down spurious calls during application shutdown or exit. Derived classes may call this if the appropriate time is known. </p>

<p>Reimplemented in <a class="el" href="class_manual_call_queue.html#a3cf6a182f6e459537c1275fbd95c01f1">ManualCallQueue</a>, and <a class="el" href="class_gui_call_queue.html#ab250779e0886f1d309c3efd9260dfeaa">GuiCallQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a0b243598ec53b127ac0557a1be058a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_call_queue.html#a0b243598ec53b127ac0557a1be058a4c">CallQueue::signal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A queue is signaled on the transition from empty to non-empty. Derived classes implement this function to perform a notification so that <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> will be called. For example, by triggering a <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classWaitableEvent.html">WaitableEvent</a>.</p>
<dl class="section note"><dt>Note:</dt><dd>Due to the implementation the queue can remain signaled for one extra cycle. This does not happen under load and is not an issue in practice. </dd></dl>

</div>
</div>
<a class="anchor" id="a171530cbaa7b1b4f4712aa940e7cd64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_call_queue.html#a171530cbaa7b1b4f4712aa940e7cd64c">CallQueue::reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vf_CallQueue.h</li>
<li>vf_CallQueue.cpp</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 15 2012 02:13:43 for VFLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
