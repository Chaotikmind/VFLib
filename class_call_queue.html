<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VFLib: CallQueue Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">VFLib
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CallQueue Class Reference<div class="ingroups"><a class="el" href="group__vf__concurrent.html">vf_concurrent</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A FIFO for calling functors asynchronously.  
 <a href="class_call_queue.html#details">More...</a></p>

<p><code>#include &quot;vf_CallQueue.h&quot;</code></p>

<p>Inherited by <a class="el" href="class_gui_call_queue.html">GuiCallQueue</a>, <a class="el" href="class_manual_call_queue.html">ManualCallQueue</a>, and <a class="el" href="class_thread_with_call_queue.html">ThreadWithCallQueue</a>.</p>

<p><a href="class_call_queue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89de47524d62877f2198a58d78d1b0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a89de47524d62877f2198a58d78d1b0ed">CallQueue</a> (<a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a> name)</td></tr>
<tr class="memitem:a243ab6a2217eb227bf4b6050447ead01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a243ab6a2217eb227bf4b6050447ead01">~CallQueue</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7cbce7a131504706ba6c36bcab846f87"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a7cbce7a131504706ba6c36bcab846f87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">call</a> (Fn f)</td></tr>
<tr class="memdesc:a7cbce7a131504706ba6c36bcab846f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call and possibly synchronize.  <a href="#a7cbce7a131504706ba6c36bcab846f87"></a><br/></td></tr>
<tr class="memitem:aeb35530fa2af19554d407028bdb18621"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:aeb35530fa2af19554d407028bdb18621"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aeb35530fa2af19554d407028bdb18621">callf</a> (Functor const &amp;f)</td></tr>
<tr class="memdesc:aeb35530fa2af19554d407028bdb18621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a functor and possibly synchronize.  <a href="#aeb35530fa2af19554d407028bdb18621"></a><br/></td></tr>
<tr class="memitem:a53ca17ee96966a0720ffc00d25cd7c55"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 &gt; </td></tr>
<tr class="memitem:a53ca17ee96966a0720ffc00d25cd7c55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a53ca17ee96966a0720ffc00d25cd7c55">call</a> (Fn f, const T1 &amp;t1)</td></tr>
<tr class="memdesc:a53ca17ee96966a0720ffc00d25cd7c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with one parameter.  <a href="#a53ca17ee96966a0720ffc00d25cd7c55"></a><br/></td></tr>
<tr class="memitem:a75c95e9a8dbf8b59a5b35ad69b475bea"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a75c95e9a8dbf8b59a5b35ad69b475bea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a75c95e9a8dbf8b59a5b35ad69b475bea">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2)</td></tr>
<tr class="memdesc:a75c95e9a8dbf8b59a5b35ad69b475bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with two parameters.  <a href="#a75c95e9a8dbf8b59a5b35ad69b475bea"></a><br/></td></tr>
<tr class="memitem:a6c766f4f7b30c4ca9848137b4354661b"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a6c766f4f7b30c4ca9848137b4354661b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a6c766f4f7b30c4ca9848137b4354661b">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</td></tr>
<tr class="memdesc:a6c766f4f7b30c4ca9848137b4354661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with three parameters.  <a href="#a6c766f4f7b30c4ca9848137b4354661b"></a><br/></td></tr>
<tr class="memitem:aeee07730ce08cbad6817f74f8c44cec6"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:aeee07730ce08cbad6817f74f8c44cec6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aeee07730ce08cbad6817f74f8c44cec6">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4)</td></tr>
<tr class="memdesc:aeee07730ce08cbad6817f74f8c44cec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with four parameters.  <a href="#aeee07730ce08cbad6817f74f8c44cec6"></a><br/></td></tr>
<tr class="memitem:abe92343a1e68afa03205f1922f2925bf"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </td></tr>
<tr class="memitem:abe92343a1e68afa03205f1922f2925bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#abe92343a1e68afa03205f1922f2925bf">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5)</td></tr>
<tr class="memdesc:abe92343a1e68afa03205f1922f2925bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with five parameters.  <a href="#abe92343a1e68afa03205f1922f2925bf"></a><br/></td></tr>
<tr class="memitem:a22e52d97ebd902fb6e55db0653baca91"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </td></tr>
<tr class="memitem:a22e52d97ebd902fb6e55db0653baca91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a22e52d97ebd902fb6e55db0653baca91">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6)</td></tr>
<tr class="memdesc:a22e52d97ebd902fb6e55db0653baca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with six parameters.  <a href="#a22e52d97ebd902fb6e55db0653baca91"></a><br/></td></tr>
<tr class="memitem:aa1dcb54661197c4ef69e9cd5992d1b61"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </td></tr>
<tr class="memitem:aa1dcb54661197c4ef69e9cd5992d1b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aa1dcb54661197c4ef69e9cd5992d1b61">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6, const T7 &amp;t7)</td></tr>
<tr class="memdesc:aa1dcb54661197c4ef69e9cd5992d1b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with seven parameters.  <a href="#aa1dcb54661197c4ef69e9cd5992d1b61"></a><br/></td></tr>
<tr class="memitem:ad65c756d0aca3d4bc44ded759a4ffe09"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </td></tr>
<tr class="memitem:ad65c756d0aca3d4bc44ded759a4ffe09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#ad65c756d0aca3d4bc44ded759a4ffe09">call</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6, const T7 &amp;t7, const T8 &amp;t8)</td></tr>
<tr class="memdesc:ad65c756d0aca3d4bc44ded759a4ffe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with eight parameters.  <a href="#ad65c756d0aca3d4bc44ded759a4ffe09"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a7b7121a53b44c35b82358544a6a7cea0"><td class="memTemplParams" colspan="2">template&lt;class Fn &gt; </td></tr>
<tr class="memitem:a7b7121a53b44c35b82358544a6a7cea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">queue</a> (Fn f)</td></tr>
<tr class="memdesc:a7b7121a53b44c35b82358544a6a7cea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call without synchronizing.  <a href="#a7b7121a53b44c35b82358544a6a7cea0"></a><br/></td></tr>
<tr class="memitem:aa5b9237e85067d7199fab8b1bd20bb90"><td class="memTemplParams" colspan="2">template&lt;class Functor &gt; </td></tr>
<tr class="memitem:aa5b9237e85067d7199fab8b1bd20bb90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aa5b9237e85067d7199fab8b1bd20bb90">queuef</a> (Functor const &amp;f)</td></tr>
<tr class="memdesc:aa5b9237e85067d7199fab8b1bd20bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a functor.  <a href="#aa5b9237e85067d7199fab8b1bd20bb90"></a><br/></td></tr>
<tr class="memitem:a5c9344aa538b251ac06eb34446e7c35b"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 &gt; </td></tr>
<tr class="memitem:a5c9344aa538b251ac06eb34446e7c35b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a5c9344aa538b251ac06eb34446e7c35b">queue</a> (Fn f, const T1 &amp;t1)</td></tr>
<tr class="memdesc:a5c9344aa538b251ac06eb34446e7c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with one parameter.  <a href="#a5c9344aa538b251ac06eb34446e7c35b"></a><br/></td></tr>
<tr class="memitem:ab0cad2c0df0acd40dedd604944324c8a"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab0cad2c0df0acd40dedd604944324c8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#ab0cad2c0df0acd40dedd604944324c8a">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2)</td></tr>
<tr class="memdesc:ab0cad2c0df0acd40dedd604944324c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with two parameters.  <a href="#ab0cad2c0df0acd40dedd604944324c8a"></a><br/></td></tr>
<tr class="memitem:a4dcedf43d04d7e437b5c48d67af2227b"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a4dcedf43d04d7e437b5c48d67af2227b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a4dcedf43d04d7e437b5c48d67af2227b">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3)</td></tr>
<tr class="memdesc:a4dcedf43d04d7e437b5c48d67af2227b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with three parameters.  <a href="#a4dcedf43d04d7e437b5c48d67af2227b"></a><br/></td></tr>
<tr class="memitem:a40114f40ef2fd821ef3052087407709d"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:a40114f40ef2fd821ef3052087407709d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a40114f40ef2fd821ef3052087407709d">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4)</td></tr>
<tr class="memdesc:a40114f40ef2fd821ef3052087407709d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with four parameters.  <a href="#a40114f40ef2fd821ef3052087407709d"></a><br/></td></tr>
<tr class="memitem:aa95d663e966dfb8bc1a2e319ec50fee8"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </td></tr>
<tr class="memitem:aa95d663e966dfb8bc1a2e319ec50fee8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#aa95d663e966dfb8bc1a2e319ec50fee8">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5)</td></tr>
<tr class="memdesc:aa95d663e966dfb8bc1a2e319ec50fee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with five parameters.  <a href="#aa95d663e966dfb8bc1a2e319ec50fee8"></a><br/></td></tr>
<tr class="memitem:a6be8041cbcd66592a3daa3a7322cda22"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </td></tr>
<tr class="memitem:a6be8041cbcd66592a3daa3a7322cda22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a6be8041cbcd66592a3daa3a7322cda22">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6)</td></tr>
<tr class="memdesc:a6be8041cbcd66592a3daa3a7322cda22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with six parameters.  <a href="#a6be8041cbcd66592a3daa3a7322cda22"></a><br/></td></tr>
<tr class="memitem:a3f120f81a32916e1f0e2b4ae1e19332e"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </td></tr>
<tr class="memitem:a3f120f81a32916e1f0e2b4ae1e19332e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a3f120f81a32916e1f0e2b4ae1e19332e">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6, const T7 &amp;t7)</td></tr>
<tr class="memdesc:a3f120f81a32916e1f0e2b4ae1e19332e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with seven parameters.  <a href="#a3f120f81a32916e1f0e2b4ae1e19332e"></a><br/></td></tr>
<tr class="memitem:a53cd6e6466829566ced2b991cfac6d22"><td class="memTemplParams" colspan="2">template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </td></tr>
<tr class="memitem:a53cd6e6466829566ced2b991cfac6d22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a53cd6e6466829566ced2b991cfac6d22">queue</a> (Fn f, const T1 &amp;t1, const T2 &amp;t2, const T3 &amp;t3, const T4 &amp;t4, const T5 &amp;t5, const T6 &amp;t6, const T7 &amp;t7, const T8 &amp;t8)</td></tr>
<tr class="memdesc:a53cd6e6466829566ced2b991cfac6d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function call with eight parameters.  <a href="#a53cd6e6466829566ced2b991cfac6d22"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7b4ecb95445c00c815bc2407c9e008b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7">synchronize</a> ()</td></tr>
<tr class="memdesc:a7b4ecb95445c00c815bc2407c9e008b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the queue.  <a href="#a7b4ecb95445c00c815bc2407c9e008b7"></a><br/></td></tr>
<tr class="memitem:ace99f6efb1cd9e6b3e0dac80fbb15690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#ace99f6efb1cd9e6b3e0dac80fbb15690">close</a> ()</td></tr>
<tr class="memdesc:ace99f6efb1cd9e6b3e0dac80fbb15690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the queue.  <a href="#ace99f6efb1cd9e6b3e0dac80fbb15690"></a><br/></td></tr>
<tr class="memitem:a0b243598ec53b127ac0557a1be058a4c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a0b243598ec53b127ac0557a1be058a4c">signal</a> ()=0</td></tr>
<tr class="memdesc:a0b243598ec53b127ac0557a1be058a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification when a queue is signaled.  <a href="#a0b243598ec53b127ac0557a1be058a4c"></a><br/></td></tr>
<tr class="memitem:a171530cbaa7b1b4f4712aa940e7cd64c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a171530cbaa7b1b4f4712aa940e7cd64c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html#a171530cbaa7b1b4f4712aa940e7cd64c">reset</a> ()=0</td></tr>
<tr class="memdesc:a171530cbaa7b1b4f4712aa940e7cd64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notification when a queue becomes empty. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This object is an alternative to traditional locking techniques used to implement concurrent systems. Instead of acquiring a mutex to change shared data, a functor is queued for later execution (usually on another thread). The execution of the functor applies the transformation to the shared state that was formerly performed within a lock (i.e. <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classCriticalSection.html">CriticalSection</a>).</p>
<p>For read operations on shared data, instead of acquiring a mutex and accessing the data directly, copies are made (one for each thread), and the thread accesses its copy without acquiring a lock. One thread owns the master copy of the shared state. Requests for changing shared state are made by other threads by posting functors to the master thread's <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>. The master thread notifies other threads of changes by posting functors to their respective associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>, using the Listeners interface.</p>
<p>The purpose of the functor is to encapsulate one mutation of shared state to guarantee progress towards a consensus of the concurrent data among participating threads. Functors should execute quickly, ideally in constant time. Dynamically allocated objects of class type passed as functor parameters should, in general, be reference counted. The <a class="el" href="class_concurrent_object.html" title="A reference counted object, deleted on a separate thread.">ConcurrentObject</a> class is ideal for meeting this requirement, and has the additional benefit that the workload of deletion is performed on a separate, provided thread. This queue is not a replacement for a thread pool or job queue type system.</p>
<p>A <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is considered signaled when one or more functors are present. Functors are executed during a call to <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a>. The operation of executing functors via the call to <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called synchronizing the queue. It can more generally be thought of as synchronizing multiple copies of shared data between threads.</p>
<p>Although there is some extra work required to set up and maintain this system, the benefits are significant. Since shared data is only synchronized at well defined times, the programmer can reason and make strong statements about the correctness of the concurrent system. For example, if an <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classAudioIODeviceCallback.html">AudioIODeviceCallback</a> synchronizes the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> only at the beginning of its execution, it is guaranteed that shared data will remain the same throughout the remainder of the function.</p>
<p>Because shared data is accessed for reading without a lock, upper bounds on the run time performance can easily be calculated and assured. Compare this with the use of a mutex - the run time performance experiences a combinatorial explosion of possibilities depending on the complex interaction of multiple threads.</p>
<p>Since a <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is almost always used to invoke parameterized member functions of objects, the <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call()</a> function comes in a variety of convenient forms to make usage easy:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> func1 (<span class="keywordtype">int</span>);

    <span class="keyword">struct </span>Object
    {
      <span class="keywordtype">void</span> func2 (<span class="keywordtype">void</span>);
      <span class="keywordtype">void</span> func3 (<a class="codeRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a> name);

      <span class="keyword">static</span> <span class="keywordtype">void</span> func4 ();
    };

    <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> fifo (<span class="stringliteral">&quot;Example&quot;</span>);

    <span class="keywordtype">void</span> example ()
    {
      fifo.call (func1, 42);               <span class="comment">// same as: func1 (42)</span>

      Object* <span class="keywordtype">object</span> = <span class="keyword">new</span> Object;

      fifo.call (&amp;Object::func2, <span class="keywordtype">object</span>);  <span class="comment">// same as: object-&gt;func2 ()</span>

      fifo.call (&amp;Object::func3,           <span class="comment">// same as: object-&gt;funcf (&quot;Label&quot;)</span>
                 <span class="keywordtype">object</span>,
                 <span class="stringliteral">&quot;Label&quot;</span>);

      fifo.call (&amp;Object::func4);          <span class="comment">// even static members can be called.</span>

      fifo.callf (bind (&amp;Object::func2,    <span class="comment">// same as: object-&gt;func2 ()</span>
                        <span class="keywordtype">object</span>));
    }
</pre></div><p>Invariants:</p>
<ul>
<li>Functors can be added from any thread at any time, to any queue which is not closed.</li>
</ul>
<ul>
<li>When <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called, functors are called and deleted.</li>
</ul>
<ul>
<li>The thread from which <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called is considered the thread associated with the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.</li>
</ul>
<ul>
<li>Functors queued by the same thread always execute in the same order they were queued.</li>
</ul>
<ul>
<li>Functors are guaranteed to execute. It is an error if the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is deleted while there are functors in it.</li>
</ul>
<p>Normally, you will not use <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> directly, but one of its subclasses instead. The <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is one of a handful of objects that work together to implement this system of concurrent data access.</p>
<p>For performance considerations, this implementation is wait-free for producers and mostly wait-free for consumers. It also uses a lock-free and wait-free (in the fast path) custom memory allocator.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_gui_call_queue.html" title="A CallQueue handled by the Juce message thread (gui).">GuiCallQueue</a>, <a class="el" href="class_manual_call_queue.html" title="A CallQueue that requires periodic manual synchronization.">ManualCallQueue</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a89de47524d62877f2198a58d78d1b0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_call_queue.html#a89de47524d62877f2198a58d78d1b0ed">CallQueue::CallQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classString.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string identifying the associated thread for debugging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a243ab6a2217eb227bf4b6050447ead01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_call_queue.html#a243ab6a2217eb227bf4b6050447ead01">CallQueue::~CallQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It is an error to destroy a <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> that still contains functors. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7cbce7a131504706ba6c36bcab846f87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parameters are evaluated immediately and added to the queue as a packaged functor. If the current thread of execution is the same as the thread associated with the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>, <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is called automatically. This behavior can be avoided by using <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue()</a> instead.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to call followed by up to eight parameters, evaluated immediately. The parameter list must match the function signature. For class member functions, the first argument must be a pointer to the class object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue</a></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Provide an example of when <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> is needed in <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb35530fa2af19554d407028bdb18621"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#aeb35530fa2af19554d407028bdb18621">CallQueue::callf</a> </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use this when you want to perform the bind yourself.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to add, typically the return value of a call to bind(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53ca17ee96966a0720ffc00d25cd7c55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a75c95e9a8dbf8b59a5b35ad69b475bea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c766f4f7b30c4ca9848137b4354661b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeee07730ce08cbad6817f74f8c44cec6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe92343a1e68afa03205f1922f2925bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22e52d97ebd902fb6e55db0653baca91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1dcb54661197c4ef69e9cd5992d1b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T7 &amp;&#160;</td>
          <td class="paramname"><em>t7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad65c756d0aca3d4bc44ded759a4ffe09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87">CallQueue::call</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T7 &amp;&#160;</td>
          <td class="paramname"><em>t7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T8 &amp;&#160;</td>
          <td class="paramname"><em>t8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b7121a53b44c35b82358544a6a7cea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parameters are evaluated immediately, then the resulting functor is added to the queue. This is used to postpone the call to <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> when there would be adverse side effects to executing the function immediately. In this example, we use <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue()</a> instead of <a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call()</a> to avoid a deadlock:</p>
<div class="fragment"><pre class="fragment">      <span class="keyword">struct </span>SharedState;           <span class="comment">// contains data shared between threads</span>

      <a class="code" href="class_concurrent_state.html" title="Encapsulation for data accessed by multiple threads.">ConcurrentState &lt;SharedState&gt;</a> sharedState;

      <span class="keywordtype">void</span> stateChanged ()
      {
        <a class="code" href="class_concurrent_state_1_1_read_access.html" title="Read only access to a ConcurrentState.">ConcurrentState &lt;SharedState&gt;::ReadAccess</a> state (sharedState);

        <span class="comment">// (access state)</span>
      }

      <a class="code" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> fifo;

      <span class="keywordtype">void</span> changeState ()
      {
        <a class="code" href="class_concurrent_state_1_1_write_access.html" title="Read/write access to a ConcurrentState.">ConcurrentState &lt;State&gt;::WriteAccess</a> state (sharedState);

        <span class="comment">// (modify state)</span>

        fifo.<a class="code" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call</a> (&amp;stateChanged);  <span class="comment">// BUG: DEADLOCK because of the implicit synchronize().</span>

        fifo.<a class="code" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0" title="Add a function call without synchronizing.">queue</a> (&amp;stateChanged); <span class="comment">// Okay, synchronize() will be called later,</span>
                                    <span class="comment">// after the write lock is released.</span>
      }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to call followed by up to eight parameters, evaluated immediately. The parameter list must match the function signature. For non-static class member functions, the first argument must be a pointer an instance of the class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="class_call_queue.html#a7cbce7a131504706ba6c36bcab846f87" title="Add a function call and possibly synchronize.">call</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b9237e85067d7199fab8b1bd20bb90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#aa5b9237e85067d7199fab8b1bd20bb90">CallQueue::queuef</a> </td>
          <td>(</td>
          <td class="paramtype">Functor const &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use this when you want to perform the bind yourself.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor to add, typically the return value of a call to bind(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c9344aa538b251ac06eb34446e7c35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0cad2c0df0acd40dedd604944324c8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dcedf43d04d7e437b5c48d67af2227b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40114f40ef2fd821ef3052087407709d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa95d663e966dfb8bc1a2e319ec50fee8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6be8041cbcd66592a3daa3a7322cda22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f120f81a32916e1f0e2b4ae1e19332e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T7 &amp;&#160;</td>
          <td class="paramname"><em>t7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53cd6e6466829566ced2b991cfac6d22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Fn , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#a7b7121a53b44c35b82358544a6a7cea0">CallQueue::queue</a> </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T5 &amp;&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T6 &amp;&#160;</td>
          <td class="paramname"><em>t6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T7 &amp;&#160;</td>
          <td class="paramname"><em>t7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T8 &amp;&#160;</td>
          <td class="paramname"><em>t8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b4ecb95445c00c815bc2407c9e008b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7">CallQueue::synchronize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A synchronize operation calls all functors in the queue. If a functor causes additional functors to be added, they are eventually executed before <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> returns. Derived class call this when the queue is signaled, and optionally at any other time. Calling this function from more than one thread simultaneously is undefined.</p>
<dl class="section return"><dt>Returns:</dt><dd>true if any functors were executed. </dd></dl>

<p>Reimplemented in <a class="el" href="class_manual_call_queue.html#a8934bcdca202c9f5d190565f68583687">ManualCallQueue</a>, and <a class="el" href="class_gui_call_queue.html#a63f2c96d55cc954cf373d85f509f6dd3">GuiCallQueue</a>.</p>

</div>
</div>
<a class="anchor" id="ace99f6efb1cd9e6b3e0dac80fbb15690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_call_queue.html#ace99f6efb1cd9e6b3e0dac80fbb15690">CallQueue::close</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functors may not be added after this routine is called. This is used for diagnostics, to track down spurious calls during application shutdown or exit. Derived classes may call this if the appropriate time is known. </p>

<p>Reimplemented in <a class="el" href="class_manual_call_queue.html#a3cf6a182f6e459537c1275fbd95c01f1">ManualCallQueue</a>, and <a class="el" href="class_gui_call_queue.html#ab250779e0886f1d309c3efd9260dfeaa">GuiCallQueue</a>.</p>

</div>
</div>
<a class="anchor" id="a0b243598ec53b127ac0557a1be058a4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_call_queue.html#a0b243598ec53b127ac0557a1be058a4c">CallQueue::signal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A queue is signaled on the transition from empty to non-empty. Derived classes implement this function to perform a notification so that <a class="el" href="class_call_queue.html#a7b4ecb95445c00c815bc2407c9e008b7" title="Synchronize the queue.">synchronize()</a> will be called. For example, by triggering a <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classWaitableEvent.html">WaitableEvent</a>.</p>
<p>Due to the implementation the queue can remain signaled for one extra cycle. This does not happen under load and is not an issue in practice. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vf_CallQueue.h</li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 11 2012 12:40:40 for VFLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
