<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VFLib: vf_concurrent</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">VFLib
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">vf_concurrent</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes for building a concurrent system.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_allocated_by.html">AllocatedBy&lt; AllocatorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized allocation for heap objects.  <a href="class_allocated_by.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fifo_free_store_without_t_l_s.html">FifoFreeStoreWithoutTLS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free and mostly wait-free memory allocator optimized for FIFO style usage patterns.  <a href="class_fifo_free_store_without_t_l_s.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_fifo_free_store_with_t_l_s.html">FifoFreeStoreWithTLS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free and mostly wait-free memory allocator optimized for FIFO style usage patterns.  <a href="class_fifo_free_store_with_t_l_s.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_global_fifo_free_store.html">GlobalFifoFreeStore&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A FifoFreeStore singleton.  <a href="class_global_fifo_free_store.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_global_paged_free_store.html">GlobalPagedFreeStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_paged_free_store.html" title="Lock-free memory allocator for fixed size pages.">PagedFreeStore</a> singleton.  <a href="class_global_paged_free_store.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_paged_free_store.html">PagedFreeStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock-free memory allocator for fixed size pages.  <a href="class_paged_free_store.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_call_queue.html">CallQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A FIFO for calling functors asynchronously.  <a href="class_call_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrent_object.html">ConcurrentObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference counted object, deleted on a separate thread.  <a href="class_concurrent_object.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_concurrent_state.html">ConcurrentState&lt; Object &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation for data accessed by multiple threads.  <a href="class_concurrent_state.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gui_call_queue.html">GuiCallQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> handled by the Juce message thread (gui).  <a href="class_gui_call_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_listeners_base.html">ListenersBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A group of concurrent Listeners.  <a href="class_listeners_base.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_manual_call_queue.html">ManualCallQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> that requires periodic manual synchronization.  <a href="class_manual_call_queue.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_generic_scoped_read_lock.html">GenericScopedReadLock&lt; LockType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple consumer, single producer (MCSP) synchronization primitive.  <a href="struct_generic_scoped_read_lock.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_with_call_queue.html">ThreadWithCallQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_interruptible_thread.html" title="A thread with soft interruption support.">InterruptibleThread</a> with a <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>.  <a href="class_thread_with_call_queue.html#details">More...</a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This object is an alternative to traditional locking techniques used to implement concurrent systems. Instead of acquiring a mutex to change shared data, a functor is queued for later execution (usually on another thread). The execution of the functor applies the transformation to the shared state that was formerly performed within a lock (i.e. <a class="elRef" doxygen="juce.tag:http://www.rawmaterialsoftware.com/juce/api//" href="http://www.rawmaterialsoftware.com/juce/api/classCriticalSection.html">CriticalSection</a>).</p>
<p>For read operations on shared data, instead of acquiring a mutex and accessing the data directly, copies are made (one for each thread), and the thread accesses its copy without acquiring a lock. One thread owns the master copy of the shared state. Requests for changing shared state are made by other threads by posting functors to the master thread's <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>. The master thread notifies other threads of changes by posting functors to their respective associated <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a>, using the Listeners interface.</p>
<p>The purpose of the functor is to encapsulate one mutation of shared state to guarantee progress towards a consensus of the concurrent data among participating threads. Functors should execute quickly, ideally in constant time. Dynamically allocated objects of class type passed as functor parameters should, in general, be reference counted. The <a class="el" href="class_concurrent_object.html" title="A reference counted object, deleted on a separate thread.">ConcurrentObject</a> class is ideal for meeting this requirement, and has the additional benefit that the workload of deletion is performed on a separate, provided thread. This queue is not a replacement for a thread pool or job queue type system.</p>
<p>A <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> is considered signaled when one or more functors are present. Functors are executed during a call to synchronize(). The operation of executing functors via the call to synchronize() is called synchronizing the queue. It can more generally be thought of as synchronizing multiple copies of shared data between threads.</p>
<p>Although there is some extra work required to set up and maintain this system, the benefits are significant. Since shared data is only synchronized at well defined times, the programmer can reason and make strong statements about the correctness of the concurrent system. For example, if the audioDeviceIOCallback synchronizes the <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> only at the beginning of its execution, it is guaranteed that shared data will remain the same throughout the remainder of the function.</p>
<p>Because shared data is accessed for reading without a lock, upper bounds on the run time performance can easily be calculated and assured. Compare this with the use of a mutex - the run time performance experiences a combinatorial explosion of possibilities depending on the complex interaction of multiple threads.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Discuss the limit on the size of the functor used in <a class="el" href="class_call_queue.html" title="A FIFO for calling functors asynchronously.">CallQueue</a> and Listeners. </dd></dl>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 11 2012 15:44:56 for VFLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
